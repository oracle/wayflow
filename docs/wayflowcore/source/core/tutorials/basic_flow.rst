.. _core_basic_flow:

==============================================
Build a Simple Fixed-Flow Assistant with Flows
==============================================

.. |python-icon| image:: ../../_static/icons/python-icon.svg
   :width: 40px
   :height: 40px

.. grid:: 2

    .. grid-item-card:: |python-icon| Download Python Script
        :link: ../end_to_end_code_examples/tutorial_flow.py
        :link-alt: Simple flow tutorial script

        Python script/notebook for this guide.

.. admonition:: Prerequisites

   This guide does not assume any prior knowledge about WayFlow. However, it assumes the reader has a
   basic knowledge of Large Language Models (LLMs).

   You will need a working installation of WayFlow - see :doc:`Installation <../installation>`.

Learning goals
==============

In this tutorial, you will develop a simple HR chatbot that answers an employee's HR-related questions.

By doing this tutorial, you will:

#. Learn the basics of using a :ref:`Flow <flow>` to build an assistant.
#. Learn how to pass values around in WayFlow.
#. Learn how to use some of the more common types of steps.

.. tip::
   Another type of assistant supported by WayFlow is :ref:`Agents <agent>`. To learn more about building conversational
   assistants with Agents, check out the :doc:`Build a Simple Agents tutorial <basic_agent>`.

.. _primer_on_flows:

A primer on Flows
=================

A :ref:`Flow <flow>` is a type of assistant composed of individual **Steps** connected to form a coherent sequence of actions. By
using a flow-based approach WayFlow can tackle a wide range of business processes and tasks.

Each step in the :ref:`Flow <flow>` performs a specific function. The flow you will build in this tutorial uses the following types
of steps:

- :ref:`InputMessageStep <inputmessagestep>`: This gathers input from the user.
- :ref:`ToolExecutionStep <toolexecutionstep>`: In this case it runs a Python function that fetches data from another system. ``Tools`` can do more than this. Take a look at :ref:`ServerTools <servertool>` and :ref:`ClientTools <clienttool>` to find out more.
- :ref:`PromptExecutionStep <promptexecutionstep>`: This executes a prompt using a Large Language Model (LLM) and supports inserting data from other steps into the prompt.
- :ref:`OutputMessageStep <outputmessagestep>`: This is used to display information to the user.

.. note::
   For advanced LLM users: Typically, an LLM chatbot maintains a chat history to support multi-turn conversations—this is referred to as an :ref:`Agent <agent>`.
   In contrast, the ``PromptExecutionStep`` is a stateless function that simply calls the model to generate an output based on the provided input prompt.

.. _building_the_flow:

Building the flow
=================

In this tutorial, you will create an HR chatbot that answers a user's HR-related queries. You will do this by building a fixed-flow assistant
using Python code.

The chatbot will need to perform the following steps, in order, to answer a user's HR questions.

#. The user is greeted and prompted for a question.
#. The user inputs their question to the assistant.
#. The assistant uses a tool to search for the requested information, querying an HR system.
#. The assistant uses an LLM to answer the user's question using the data retrieved in the previous step.
#. The assistant returns the answer generated by the LLM to the user.

Given that you know what logical steps the assistant needs to perform to achieve the goal, how do you turn this into a working WayFlow assistant?

Turning the above logical steps into code can be broken down into several steps, each taking you towards the finished assistant. The rest of
this tutorial addresses these tasks.

Setup a Jupyter Notebook
========================

You can follow along with this tutorial by creating a Jupyter Notebook. Ensure that ``wayflowcore`` is installed — see the :doc:`installation <../installation>`
instructions for details.

Alternatively, you can use any Python environment to run the code in this tutorial.

Imports and LLM configuration
=============================

First import what is needed for this tutorial:

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Imports
   :end-before: .. end-##_Imports

WayFlow supports several LLM API providers. First choose an LLM from one of the options below:

.. include:: ../_components/llm_config_tabs.rst

.. note::
   API keys should never be stored in code. Use environment variables and/or tools such as `python-dotenv <https://pypi.org/project/python-dotenv/>`_
   instead.

Naming data
===========

Passing values between steps is a very common occurrence when building Flows. This is done using :ref:`DataFlowEdges <dataflowedge>` which define
that a value is passed from one step to another.

A step has input and output descriptors, which describe what values it requires to run and what values it produces. These can be thought of as
names that describe the step's inputs and outputs.

By default, the ``input_descriptors`` will be automatically inferred from any input from the step class that supports Jinja templating.
Parameters in a Jinja template look like this: ``{{this_is_a_template_parameter}}``. Additionally, input descriptors can be inferred from
other sources, such as the input parameters schemas of the ``tool`` for the ``ToolExecutionStep``. There will be one input descriptor for each
parameter in the template, with a name taken from the parameter. Similarly, there will be one input descriptor for each parameter required by a ``tool``.

Output descriptors can also be considered names for a step's outputs. For many steps, there will be a default name for each output. For example,
for a ``ToolExecutionStep`` the default name for the output of the step is ``ToolExecutionStep.TOOL_OUTPUT``.

Input and output descriptors can be renamed using either ``input_mappings``, or ``output_mappings`` allowing for more meaningful names.

Where we need to reference input and output descriptors in the code we use a variable to hold the name. Doing this eliminates errors related to typos.

Below are the names you will use for the values passed around in this tutorial.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_value_names
   :end-before: .. end-##_Define_value_names

Later in this tutorial, you will examine in detail how passing values works.

Specifying the steps
====================

The flow follows a simple sequence of logical steps that were defined earlier in the tutorial. They consist of prompting the user for a question,
searching the HR system for the required information, using an LLM to generate an answer from the retrieved data, and finally answering the user.

In a nutshell, the flow consists of the following steps in order:

- :ref:`StartStep <startstep>`: Acts as a starting point for the flow. It does nothing, and this is not strictly required, but if you exclude it, you will get a warning message.
- :ref:`InputMessageStep <inputmessagestep>`: Where the user is asked for input - the question the user wants to ask.
- :ref:`ToolExecutionStep <toolexecutionstep>`: Queries the HR system to look up the relevant to the user's query.
- :ref:`PromptExecutionStep <promptexecutionstep>`: Uses an LLM to ingest and interpret the HR data and the user's query to generate an answer.
- :ref:`OutputMessageStep <outputmessagestep>`: Displays the answer generated in the previous step to the user.

You now need to build each of the steps used in the flow.

START_STEP
----------

This is where the flow starts. It can take in a string to display to the user, but it is being used only as a starting point for the flow. The
message to the user is displayed in the ``USER_INPUT_STEP``.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_start_step
   :end-before: .. end-##_Define_start_step

USER_INPUT_STEP
---------------

The ``InputMessageStep`` prompts the user for information and saves the response for subsequent use. This step requires at least a message
template, which defines the prompt presented to the user. In this context, the user is welcomed and asked to provide their HR-related question.

An ``output_mapping`` is used to specify a new, more meaningful name for the ``output_descriptor`` of the step. By default, the ``output_descriptor``
for the value produced by the step is ``InputMessageStep.USER_PROVIDED_INPUT``. It is important to remember that the value is not held in this; this
is only the default name for the ``output_descriptor``. A more meaningful name would be useful, so the ``output_descriptor`` is renamed to the value
in ``HR_QUERY``. When accessing the output value of this step in a ``DataFlowEdge``, the name in ``HR_QUERY`` can be used.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_user_input_step
   :end-before: .. end-##_Define_user_input_step

HR_LOOKUP_STEP
--------------

In this case the :ref:`ToolExecutionStep <toolexecutionstep>` executes a tool, a decorated Python function, with the passed in query. Here, for
simplicity, the tool is mocked out and always returns the same data. The mock data contains HR information for two fictional employees,
``John Smith`` and ``Mary Jones``.

An ``output_mapping`` is used to specify a new, more meaningful name for the ``output_descriptor`` of this step. By default, the ``output_descriptor``
for the value produced by this step is ``ToolExecutionStep.TOOL_OUTPUT``. It is renamed to the more meaningful name in ``HR_DATA_CONTEXT``.
This name can be used in a ``DataFlowEdge`` to access the output value of the step.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_HR_lookup_step
   :end-before: .. end-##_Define_HR_lookup_step

LLM_ANSWER_STEP
---------------

The ``PromptExecutionStep`` executes a prompt using an LLM. It requires a prompt template and an LLM(s) to do so.

As in the ``USER_INPUT_STEP``, the LLM's ``output_descriptor`` is replaced with a more meaningful name.
The default ``output_descriptor`` for the output of ``PromptExecutionStep`` is ``PromptExecutionStep.OUTPUT``. It is renamed to the value
held in ``QUERY_ANSWER``. This name can be used in a ``DataFlowEdge`` to access the output value of the step.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_llm_answer_step
   :end-before: .. end-##_Define_llm_answer_step

USER_OUTPUT_STEP
----------------

The ``OutputMessageStep`` displays information to the user. It uses a message template to generate the output.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_user_output_step
   :end-before: .. end-##_Define_user_output_step

Step transitions
================

The Flow is almost done, you just need to specify the **control flow**, i.e., the transitions between the steps defined earlier.
These are straightforward here as you are building a "sequential" flow. Note that the final step, displaying the
answer to the user, transitions ``CompleteStep()`` - a step that acts as a termination point for the flow.
Alternatively, it can also transition back to the ``USER_INPUT_STEP``, giving the user another opportunity to chat
with the fixed-flow assistant.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_flow_transitions
   :end-before: .. end-##_Define_flow_transitions

In addition to defining the transitions, you must specify the **data flow**, i.e., how values are passed from one step to the next.
This is done using :ref:`DataFlowEdges <dataflowedge>`. Each :ref:`DataFlowEdge <dataflowedge>` has a ``source_step``
which defines the source step for the value, a ``source_output`` that is the name of the value, a ``destination_step``
that defines which step the value will be consumed by, and a ``destination_input`` which is the name of the input
parameter for the destination step which will consume the value.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Define_data_transitions
   :end-before: .. end-##_Define_data_transitions

Creating the assistant
======================

Finally, you create the flow by using the :ref:`Flow <flow>` class.

You set the initial step to be the ``begin_step`` and pass in ``control_flow_edges`` and ``data_flow_edges``.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Create_assistant
   :end-before: .. end-##_Create_assistant

This completes the fixed-flow HR assistant.

Running the assistant
=====================

Before we run the assistant, what are some questions that you could ask it? The following questions can be answered from the dummy HR data and are
a good starting point.

#. `What is the salary for John Smith?`
#. `Does John Smith earn more that Mary Jones?`
#. `How much annual leave does John Smith get?`

But, we can also ask the assistant questions that it shouldn't be able to answer, because it hasn't been given any data that is relevant to the
question:

#. `How much does Jones Jones earn?`
#. `What is Mary Jones favorite color?`

So with some questions ready you can now run the assistant. Within the example code below you will pass one of these questions to the assistant.

.. note::

   It is possible to create an assistant that answers one question and then returns to the beginning to start over. This could be done by connecting the
   final step back to the user input step in the final ``ControlFlowEdge``, as shown below.

   .. code:: python

      ControlFlowEdge(
         source_step=user_output_step,
         destination_step=user_input_step
      ),

Run the code below to run the assistant. It will ask the assistant a single one of the above question and exit.

.. literalinclude:: ../code_examples/tutorial_flow.py
   :language: python
   :linenos:
   :start-after: .. start-##_Run_assistant
   :end-before: .. end-##_Run_assistant

The process can be summarized as follows.

The HR Assistant first prints the welcome message defined above. Next, it captures the user's question - here you pass in a question using
``conversation.append_user_message``. It processes the input through the predefined steps and transitions, and finally returns the output.

Congratulations, you have built your first fixed-flow assistant!


Agent Spec Exporting/Loading
============================

You can export the assistant configuration to its Agent Spec configuration using the ``AgentSpecExporter``.

.. literalinclude:: ../code_examples/tutorial_flow.py
    :language: python
    :start-after: .. start-##_Export_config_to_Agent_Spec
    :end-before: .. end-##_Export_config_to_Agent_Spec


Here is what the **Agent Spec representation will look like ↓**

.. collapse:: Click here to see the assistant configuration.

   .. tabs::

      .. tab:: JSON

         .. literalinclude:: ../config_examples/tutorial_flow.json
            :language: json

      .. tab:: YAML

         .. literalinclude:: ../config_examples/tutorial_flow.yaml
            :language: yaml


You can then load the configuration back to an assistant using the ``AgentSpecLoader``.


.. literalinclude:: ../code_examples/tutorial_flow.py
    :language: python
    :start-after: .. start-##_Load_Agent_Spec_config
    :end-before: .. end-##_Load_Agent_Spec_config


.. note::

    This guide uses the following extension/plugin Agent Spec components:

    - ``PluginInputMessageNode``
    - ``PluginOutputMessageNode``

    See the list of available Agent Spec extension/plugin components in the :doc:`API Reference <../api/agentspec>`


Next steps
==========

In this tutorial, you learned how to build a fixed-flow assistant. To continue learning, check out:

- :doc:`basic_agent`.
- Read the :ref:`API Reference <api>`.
- Take a look at the :ref:`How-to Guides <how-to_guides>`.



Full code
=========

Click on the card at the :ref:`top of this page <core_basic_flow>` to download the full code
for this guide or copy the code below.

.. literalinclude:: ../end_to_end_code_examples/tutorial_flow.py
   :language: python
   :linenos:
